'use client';

import React, { useState, useEffect, useCallback, useRef } from 'react';
import { Button } from '@/components/ui/button';
import { Progress } from '@/components/ui/progress';
import { useRouter } from 'next/navigation';
import { GameStart } from '@/components/quickthinker/game-start';
import { GameResults } from '@/components/quickthinker/game-results';
import { SpeedMathRound } from '@/components/quickthinker/speed-math-round';
import { LogicMCQRound } from '@/components/quickthinker/logic-mcq-round';
import { OddOneOutRound } from '@/components/quickthinker/odd-one-out-round';
import type { GameRound, GameState, RoundResult, OddOneOutData, SpeedMathData, LogicMCQData } from '@/types/quickthinker';
import { useToast } from "@/hooks/use-toast";
import { AlertCircle, CheckCircle, Trophy } from 'lucide-react';
import { generateQuickThinkerRounds } from '@/lib/quickthinker-rounds';
import { cn } from '@/lib/utils';

const TOTAL_ROUNDS_PER_LEVEL = 5; // Rounds per level
const INITIAL_LEVEL = 1;
const MAX_LEVELS = 2; // Define maximum levels
const DEFAULT_TIME_LIMIT_MS = 15000; // Default time per round if not specified by round data

export default function QuickThinkerPage() {
    const router = useRouter();
    const { toast } = useToast();
    const [currentLevel, setCurrentLevel] = useState(INITIAL_LEVEL);
    const [gameState, setGameState] = useState<GameState>({
        status: 'idle',
        currentRound: 0,
        totalRounds: TOTAL_ROUNDS_PER_LEVEL, // Will be updated based on level rounds
        score: 0,
        totalTimeMs: 0,
        results: [],
        startTime: null,
    });
    const [rounds, setRounds] = useState<GameRound[]>([]);
    const [timeLeft, setTimeLeft] = useState(0);
    
    const timerIdRef = useRef<NodeJS.Timeout | null>(null);
    const roundStartTimeRef = useRef<number | null>(null);
    const isAnswerSubmittedRef = useRef(false);

    const handleRoundEnd = useCallback((isCorrect: boolean | null, timeTaken: number) => {
        setGameState(prev => {
            if (prev.status !== 'playing') return prev;

            const newResult: RoundResult = { roundIndex: prev.currentRound, correct: !!isCorrect, timeTakenMs: timeTaken };
            const newScore = isCorrect ? prev.score + 1 : prev.score;
            const newTotalTimeMs = prev.totalTimeMs + timeTaken;
            const newResults = [...prev.results, newResult];
            
            const isLastRoundOfLevel = prev.currentRound === rounds.length - 1;

            if (!isLastRoundOfLevel) {
                isAnswerSubmittedRef.current = false;
                return {
                    ...prev,
                    score: newScore,
                    totalTimeMs: newTotalTimeMs,
                    results: newResults,
                    currentRound: prev.currentRound + 1,
                };
            } else { // Last round of current level
                const currentLevelResults = newResults.slice(-rounds.length); // Results for the current level
                const correctInLevel = currentLevelResults.filter(r => r.correct).length;
                const timeForLevel = currentLevelResults.reduce((sum, r) => sum + r.timeTakenMs, 0);
                const avgTimePerQuestionInLevel = currentLevelResults.length > 0 ? timeForLevel / currentLevelResults.length : Infinity;

                // Easier Level progression logic: 60% correct and avg time < 7s for level 1
                const canProgress = currentLevel === 1 && 
                                    (correctInLevel / rounds.length) >= 0.6 && 
                                    avgTimePerQuestionInLevel < 7000; 
                
                if (canProgress && currentLevel < MAX_LEVELS) {
                    toast({
                        title: "Level Up!",
                        description: "Great job! Moving to the next challenge.",
                        className: "border-blue-500",
                        icon: <Trophy className="h-4 w-4 text-blue-500" />
                    });
                    setCurrentLevel(prevLevel => prevLevel + 1);
                    isAnswerSubmittedRef.current = false; // Reset for new level
                    // New rounds for new level will be generated by useEffect watching currentLevel
                    return {
                        ...prev,
                        status: 'playing',
                        currentRound: 0, // Reset for new level
                        score: newScore, // Cumulative score
                        totalTimeMs: newTotalTimeMs, // Cumulative time
                        results: newResults, // Cumulative results
                        startTime: prev.startTime, // Keep original game start time
                        // totalRounds will be updated by useEffect
                    };
                } else if (currentLevel === MAX_LEVELS || (currentLevel === 1 && !canProgress)) {
                    if (currentLevel === 1 && !canProgress) {
                        toast({
                            title: `Level ${currentLevel} Complete`,
                            description: "You didn't qualify for the next level this time. Try to be faster and more accurate!",
                            variant: "default",
                            icon: <AlertCircle className="h-4 w-4 text-yellow-500" />,
                        });
                    }
                     if (timerIdRef.current) {
                        clearInterval(timerIdRef.current);
                        timerIdRef.current = null;
                    }
                    return {
                        ...prev,
                        status: 'finished',
                        score: newScore,
                        totalTimeMs: newTotalTimeMs,
                        results: newResults,
                        currentRound: prev.currentRound +1, // Increment to show it's past the last round played
                    };
                }
                 // Fallback if something unexpected happens with level logic
                if (timerIdRef.current) clearInterval(timerIdRef.current);
                return { ...prev, status: 'finished', score: newScore, totalTimeMs: newTotalTimeMs, results: newResults, currentRound: prev.currentRound + 1 };
            }
        });
    }, [rounds, currentLevel, toast]);

    useEffect(() => {
        if (gameState.status === 'playing' || gameState.status === 'idle') {
            const generatedRounds = generateQuickThinkerRounds(
                TOTAL_ROUNDS_PER_LEVEL,
                currentLevel
            );
            setRounds(generatedRounds);
            
            if(gameState.status === 'playing'){
                 setGameState(prev => ({
                    ...prev,
                    currentRound: 0,
                    totalRounds: generatedRounds.length // Update totalRounds based on newly generated rounds for the level
                 }));
            } else if (gameState.status === 'idle') {
                 setGameState(prev => ({ ...prev, totalRounds: generatedRounds.length }));
            }
        }
    }, [currentLevel, gameState.status]);


    const startGame = useCallback(() => {
        setCurrentLevel(INITIAL_LEVEL);
        setGameState({
            status: 'playing',
            currentRound: 0,
            totalRounds: TOTAL_ROUNDS_PER_LEVEL, // Initial, will be updated by useEffect
            score: 0,
            totalTimeMs: 0,
            results: [],
            startTime: Date.now(),
        });
        isAnswerSubmittedRef.current = false;
    }, []);

    useEffect(() => {
        if (gameState.status === 'playing' && !isAnswerSubmittedRef.current && rounds.length > 0 && gameState.currentRound < rounds.length) {
            const currentRoundData = rounds[gameState.currentRound];
            const timeLimit = currentRoundData?.timeLimitMs || DEFAULT_TIME_LIMIT_MS;
            
            setTimeLeft(timeLimit);
            roundStartTimeRef.current = Date.now();

            if (timerIdRef.current) {
                clearInterval(timerIdRef.current);
            }

            const newTimerId = setInterval(() => {
                setTimeLeft(prevTime => {
                    if (prevTime <= 100) {
                        clearInterval(newTimerId);
                        timerIdRef.current = null;
                        const elapsed = Date.now() - (roundStartTimeRef.current || Date.now());
                        handleRoundEnd(false, Math.min(elapsed, timeLimit));
                        return 0;
                    }
                    return prevTime - 100;
                });
            }, 100);
            timerIdRef.current = newTimerId;

            return () => {
                if (timerIdRef.current) {
                     clearInterval(timerIdRef.current);
                     timerIdRef.current = null;
                }
            };
        } else if (gameState.status !== 'playing' && timerIdRef.current) {
            clearInterval(timerIdRef.current);
            timerIdRef.current = null;
        }
    // Ensure rounds is a dependency, as its change (new level) should re-trigger timer setup.
    }, [gameState.status, gameState.currentRound, rounds, handleRoundEnd]);


    const handleComplete = useCallback((answerGiven: string | number | boolean) => {
        if (isAnswerSubmittedRef.current || gameState.status !== 'playing' || gameState.currentRound >= rounds.length) return;
        
        isAnswerSubmittedRef.current = true;
        if (timerIdRef.current) {
            clearInterval(timerIdRef.current);
            timerIdRef.current = null;
        }

        const timeTaken = Date.now() - (roundStartTimeRef.current || Date.now());
        const currentRoundDetails = rounds[gameState.currentRound];
        
        let isCorrect = false;
        if (currentRoundDetails.type === 'odd-one-out') {
             // For odd-one-out, answerGiven is the ID of the selected option.
             // We compare it with the correctAnswer which is the ID of the odd option.
            isCorrect = String(answerGiven) === String(currentRoundDetails.correctAnswer);
        } else {
            isCorrect = String(answerGiven).toLowerCase() === String(currentRoundDetails.correctAnswer).toLowerCase();
        }


        if (isCorrect) {
            toast({
                title: "Correct!",
                description: `+1 point! Score: ${gameState.score + 1}`,
                className: "border-green-500",
                icon: <CheckCircle className="h-4 w-4 text-green-500" />,
            });
        } else {
            toast({
                title: "Incorrect!",
                description: `Correct answer was: ${currentRoundDetails.correctAnswer}`,
                variant: "destructive",
                icon: <AlertCircle className="h-4 w-4 text-red-500" />,
            });
        }

        setTimeout(() => {
            handleRoundEnd(isCorrect, timeTaken);
        }, 1200); 
    }, [gameState.status, gameState.currentRound, gameState.score, rounds, toast, handleRoundEnd]);
    

    const renderRound = () => {
        if (gameState.status !== 'playing' || gameState.currentRound >= rounds.length || !rounds[gameState.currentRound]) {
            if(gameState.status === 'playing' && rounds.length === 0 && currentLevel > INITIAL_LEVEL) {
                return <p className="text-lg font-semibold text-primary animate-pulse">Loading Next Level...</p>;
            }
            return null;
        }

        const round = rounds[gameState.currentRound];

        switch (round.type) {
            case 'speed-math':
                return <SpeedMathRound roundData={round.data as SpeedMathData} onComplete={(ans) => handleComplete(ans)} />;
            case 'logic-mcq':
                return <LogicMCQRound roundData={round.data as LogicMCQData} onComplete={(ans) => handleComplete(ans)} />;
            case 'odd-one-out':
                 // Pass the ID of the selected option to handleComplete
                return <OddOneOutRound roundData={round.data as OddOneOutData} onComplete={(selectedOptionId) => handleComplete(selectedOptionId)} />;
            default:
                console.warn("Unknown round type:", (round as any).type);
                const timeTaken = Date.now() - (roundStartTimeRef.current || Date.now());
                if(!isAnswerSubmittedRef.current){
                    handleRoundEnd(null, timeTaken); 
                }
                return <p>Unsupported round type. Skipping...</p>;
        }
    };

    const currentRoundForProgress = rounds[gameState.currentRound];
    const timeLimitForProgress = currentRoundForProgress?.timeLimitMs || DEFAULT_TIME_LIMIT_MS;

    return (
        <div className="container mx-auto flex flex-col items-center justify-center min-h-screen p-4">
            {gameState.status === 'idle' && (
                <GameStart onStartGame={startGame} />
            )}

            {gameState.status === 'playing' && rounds.length > 0 && gameState.currentRound < rounds.length && (
                <div className="w-full max-w-md text-center">
                     <div className="mb-8">
                         <h1 className="text-3xl font-bold mb-1 text-primary animate-pulse-text-glow">QuickThinker</h1>
                         <p className="text-lg font-semibold text-foreground">Level {currentLevel} - Round {gameState.currentRound + 1} / {rounds.length}</p>
                         <p className="text-sm text-muted-foreground">{rounds[gameState.currentRound]?.type.replace(/-/g, ' ').toUpperCase()}</p>
                     </div>
                    <div className="flex justify-between items-center mb-4 px-2">
                        <span className="text-lg font-semibold tabular-nums">Score: {gameState.score}</span>
                        <span className="text-sm text-muted-foreground tabular-nums">Time: {(timeLeft / 1000).toFixed(1)}s</span>
                    </div>
                    <Progress value={(timeLeft / timeLimitForProgress) * 100} className="w-full mb-6 h-3" />
                    <div className={cn(
                        "rounded-[var(--radius)] border bg-card text-card-foreground shadow-sm p-6 md:p-8",
                        "glass-card" 
                        )}>
                        {renderRound()}
                    </div>
                </div>
            )}

            {gameState.status === 'finished' && (
                <GameResults gameState={gameState} onRestart={startGame} />
            )}
        </div>
    );
}