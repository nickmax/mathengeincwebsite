
'use client';

import React, { useState, useEffect, useCallback, useRef } from 'react';
import { Button } from '@/components/ui/button';
import { Progress } from '@/components/ui/progress';
import { useRouter } from 'next/navigation';
import { GameStart } from '@/components/quickthinker/game-start';
import { GameResults } from '@/components/quickthinker/game-results';
import { SpeedMathRound } from '@/components/quickthinker/speed-math-round';
import { LogicMCQRound } from '@/components/quickthinker/logic-mcq-round';
import { OddOneOutRound } from '@/components/quickthinker/odd-one-out-round';
import type { GameRound, GameState, RoundResult, OddOneOutData, SpeedMathData, LogicMCQData } from '@/types/quickthinker';
import { useToast } from "@/hooks/use-toast";
import { AlertCircle, CheckCircle, Trophy } from 'lucide-react';
import { generateQuickThinkerRounds } from '@/lib/quickthinker-rounds';
import { cn } from '@/lib/utils';

const TOTAL_ROUNDS = 10; // Total rounds in the game
const INITIAL_LEVEL = 1;

export default function QuickThinkerPage() {
    const router = useRouter();
    const { toast } = useToast();
    const [currentLevel, setCurrentLevel] = useState(INITIAL_LEVEL);
    const [gameState, setGameState] = useState<GameState>({
        status: 'idle',
        currentRound: 0,
        totalRounds: TOTAL_ROUNDS,
        score: 0,
        totalTimeMs: 0,
        results: [],
        startTime: null,
    });
    const [rounds, setRounds] = useState<GameRound[]>([]);
    const [timeLeft, setTimeLeft] = useState(0); // Will be set by current round's timeLimitMs
    
    const timerIdRef = useRef<NodeJS.Timeout | null>(null);
    const roundStartTimeRef = useRef<number | null>(null);
    const isAnswerSubmittedRef = useRef(false);

    const handleRoundEnd = useCallback((isCorrect: boolean | null, timeTaken: number) => {
        setGameState(prev => {
            if (prev.status !== 'playing') return prev;

            const newResult: RoundResult = { roundIndex: prev.currentRound, correct: !!isCorrect, timeTakenMs: timeTaken };
            const newScore = isCorrect ? prev.score + 1 : prev.score;
            const newTotalTimeMs = prev.totalTimeMs + timeTaken;
            const newResults = [...prev.results, newResult];
            
            const isLastRoundOfLevel = prev.currentRound === rounds.length - 1;

            if (!isLastRoundOfLevel) { // More rounds in current level
                isAnswerSubmittedRef.current = false;
                return {
                    ...prev,
                    score: newScore,
                    totalTimeMs: newTotalTimeMs,
                    results: newResults,
                    currentRound: prev.currentRound + 1,
                };
            } else { // Last round of current level or game
                 // Check for level progression
                const currentLevelResults = newResults.filter(r => rounds[r.roundIndex]?.level === currentLevel);
                const correctInLevel = currentLevelResults.filter(r => r.correct).length;
                const timeForLevel = currentLevelResults.reduce((sum, r) => sum + r.timeTakenMs, 0);
                const avgTimePerQuestionInLevel = timeForLevel / currentLevelResults.length;

                // Level progression logic (example: 100% correct and avg time < 3s for OddOneOut)
                // For simplicity, let's assume 5 rounds per level for this example logic
                // And if currentLevel is 1 (Shapes) and all 5 are correct under 15s total (3s avg)
                const canProgress = currentLevel === 1 && 
                                    correctInLevel === (rounds.filter(r => r.level === 1).length) && 
                                    avgTimePerQuestionInLevel < 3000;
                
                if (canProgress && currentLevel < 2) { // Assuming max 2 levels for now
                    toast({
                        title: "Level Up!",
                        description: "Great job! Moving to Math challenges.",
                        className: "border-blue-500",
                        icon: <Trophy className="h-4 w-4 text-blue-500" />
                    });
                    setCurrentLevel(prevLevel => prevLevel + 1);
                    // New rounds for new level will be generated by useEffect watching currentLevel
                    // Reset round-specific state for new level:
                    isAnswerSubmittedRef.current = false;
                    return {
                        ...prev,
                        status: 'playing', // Continue playing at new level
                        currentRound: 0, // Reset current round for new level
                        score: newScore, // Keep cumulative score
                        totalTimeMs: newTotalTimeMs, // Keep cumulative time
                        results: newResults, // Keep cumulative results
                        startTime: prev.startTime // Keep original game start time
                    };

                } else if (isLastRoundOfLevel && currentLevel === 1 && !canProgress && rounds.filter(r => r.level === 1).length === currentLevelResults.length) {
                     toast({
                        title: "Level 1 Complete",
                        description: "You didn't qualify for Level 2 this time. Try to be faster and more accurate!",
                        variant: "default",
                        icon: <AlertCircle className="h-4 w-4 text-yellow-500" />,
                    });
                }


                // If no progression or it's the final level, finish game
                if (timerIdRef.current) {
                    clearInterval(timerIdRef.current);
                    timerIdRef.current = null;
                }
                return {
                    ...prev,
                    status: 'finished',
                    score: newScore,
                    totalTimeMs: newTotalTimeMs,
                    results: newResults,
                    currentRound: prev.currentRound + 1, 
                };
            }
        });
    }, [rounds, currentLevel, toast]);

    // Effect to generate rounds when level changes
    useEffect(() => {
        if (gameState.status === 'playing' || gameState.status === 'idle') { // Generate rounds if playing or starting
            const generatedRounds = generateQuickThinkerRounds(
                currentLevel === 1 ? 5 : 5, // e.g. 5 rounds for level 1 (shapes), 5 for level 2 (math)
                currentLevel
            ).filter(round => { // Filter rounds based on level
                if (currentLevel === 1) return round.type === 'odd-one-out';
                if (currentLevel === 2) return round.type === 'speed-math' || round.type === 'logic-mcq'; // Example: mix math and logic for level 2
                return true; // Default for other levels if any
            }).slice(0,5); // Ensure only 5 rounds per level for this example

            setRounds(generatedRounds);
            
            if(gameState.status === 'playing'){ // If already playing (leveling up), reset current round for new level
                 setGameState(prev => ({
                    ...prev,
                    currentRound: 0,
                    totalRounds: prev.totalRounds // Keep total game rounds if desired or update based on levels
                 }));
            }
        }
    }, [currentLevel, gameState.status]);


    const startGame = useCallback(() => {
        setCurrentLevel(INITIAL_LEVEL); // Reset to initial level
        // Rounds will be generated by the useEffect watching currentLevel and gameState.status
        setGameState({
            status: 'playing',
            currentRound: 0,
            totalRounds: TOTAL_ROUNDS, // This might need dynamic adjustment based on levels
            score: 0,
            totalTimeMs: 0,
            results: [],
            startTime: Date.now(),
        });
        isAnswerSubmittedRef.current = false;
    }, []);

    useEffect(() => {
        if (gameState.status === 'playing' && !isAnswerSubmittedRef.current && rounds.length > 0 && gameState.currentRound < rounds.length) {
            const currentRoundData = rounds[gameState.currentRound];
            const timeLimit = currentRoundData?.timeLimitMs || DEFAULT_TIME_LIMIT_MS;
            
            setTimeLeft(timeLimit);
            roundStartTimeRef.current = Date.now();

            if (timerIdRef.current) {
                clearInterval(timerIdRef.current);
            }

            const newTimerId = setInterval(() => {
                setTimeLeft(prevTime => {
                    if (prevTime <= 100) { // End round if time is up
                        clearInterval(newTimerId);
                        timerIdRef.current = null;
                        const elapsed = Date.now() - (roundStartTimeRef.current || Date.now());
                        handleRoundEnd(false, Math.min(elapsed, timeLimit)); // timeTaken is min of elapsed or limit
                        return 0;
                    }
                    return prevTime - 100;
                });
            }, 100);
            timerIdRef.current = newTimerId;

            return () => {
                if (timerIdRef.current) {
                     clearInterval(timerIdRef.current);
                     timerIdRef.current = null;
                }
            };
        } else if (gameState.status !== 'playing' && timerIdRef.current) {
            clearInterval(timerIdRef.current);
            timerIdRef.current = null;
        }
    }, [gameState.status, gameState.currentRound, rounds, handleRoundEnd]);


    const handleComplete = useCallback((answerGiven: string | number | boolean) => {
        if (isAnswerSubmittedRef.current || gameState.status !== 'playing' || gameState.currentRound >= rounds.length) return;
        
        isAnswerSubmittedRef.current = true;
        if (timerIdRef.current) {
            clearInterval(timerIdRef.current);
            timerIdRef.current = null;
        }

        const timeTaken = Date.now() - (roundStartTimeRef.current || Date.now());
        const currentRoundDetails = rounds[gameState.currentRound];
        
        // Type-safe comparison
        const isCorrect = String(answerGiven) === String(currentRoundDetails.correctAnswer);

        if (isCorrect) {
            toast({
                title: "Correct!",
                description: `+1 point! Score: ${gameState.score + 1}`,
                className: "border-green-500",
                icon: <CheckCircle className="h-4 w-4 text-green-500" />,
            });
        } else {
            toast({
                title: "Incorrect!",
                description: `Correct answer was: ${currentRoundDetails.correctAnswer}`,
                variant: "destructive",
                icon: <AlertCircle className="h-4 w-4 text-red-500" />,
            });
        }

        setTimeout(() => {
            handleRoundEnd(isCorrect, timeTaken);
        }, 1200); // Delay for user to see toast
    }, [gameState.status, gameState.currentRound, gameState.score, rounds, toast, handleRoundEnd]);
    

    const renderRound = () => {
        if (gameState.status !== 'playing' || gameState.currentRound >= rounds.length || !rounds[gameState.currentRound]) {
            if(gameState.status === 'playing' && rounds.length === 0 && currentLevel > INITIAL_LEVEL) {
                // This state means we just leveled up and new rounds are generating
                return <p className="text-lg font-semibold text-primary animate-pulse">Loading Next Level...</p>;
            }
            return null;
        }

        const round = rounds[gameState.currentRound];

        switch (round.type) {
            case 'speed-math':
                return <SpeedMathRound roundData={round.data as SpeedMathData} onComplete={(ans) => handleComplete(ans)} />;
            case 'logic-mcq':
                return <LogicMCQRound roundData={round.data as LogicMCQData} onComplete={(ans) => handleComplete(ans)} />;
            case 'odd-one-out':
                return <OddOneOutRound roundData={round.data as OddOneOutData} onComplete={(ans) => handleComplete(ans)} />;
            default:
                 // Fallback for unknown round types - skip round
                console.warn("Unknown round type:", (round as any).type);
                const timeTaken = Date.now() - (roundStartTimeRef.current || Date.now());
                 // Skip the round by calling handleRoundEnd, marking as incorrect (or null)
                 // Need to ensure this doesn't get stuck in a loop
                if(!isAnswerSubmittedRef.current){
                    handleRoundEnd(null, timeTaken); 
                }
                return <p>Unsupported round type. Skipping...</p>;
        }
    };

    const currentRoundForProgress = rounds[gameState.currentRound];
    const timeLimitForProgress = currentRoundForProgress?.timeLimitMs || DEFAULT_TIME_LIMIT_MS;

    return (
        <div className="container mx-auto flex flex-col items-center justify-center min-h-screen p-4">
            {gameState.status === 'idle' && (
                <GameStart onStartGame={startGame} />
            )}

            {gameState.status === 'playing' && rounds.length > 0 && gameState.currentRound < rounds.length && (
                <div className="w-full max-w-md text-center">
                     <div className="mb-8">
                         <h1 className="text-3xl font-bold mb-1 text-primary animate-pulse-text-glow">QuickThinker</h1>
                         <p className="text-lg font-semibold text-foreground">Level {currentLevel} - Round {gameState.currentRound + 1}</p>
                         <p className="text-sm text-muted-foreground">{rounds[gameState.currentRound]?.type.replace('-', ' ').toUpperCase()}</p>
                     </div>
                    <div className="flex justify-between items-center mb-4 px-2">
                        <span className="text-lg font-semibold tabular-nums">Score: {gameState.score}</span>
                        <span className="text-sm text-muted-foreground tabular-nums">Time: {(timeLeft / 1000).toFixed(1)}s</span>
                    </div>
                    <Progress value={(timeLeft / timeLimitForProgress) * 100} className="w-full mb-6 h-3" />
                    <div className={cn(
                        "rounded-[var(--radius)] border bg-card text-card-foreground shadow-sm p-6 md:p-8",
                        "glass-card" 
                        )}>
                        {renderRound()}
                    </div>
                </div>
            )}

            {gameState.status === 'finished' && (
                <GameResults gameState={gameState} onRestart={startGame} />
            )}
        </div>
    );
}
